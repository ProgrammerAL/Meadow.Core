//
//
//
//      Message encoders and decoders.
//
//      *************************** WARNING ***************************
//
//      THIS FILE IS AUTOMATICALLY GENERATED.  DO NOT EDIT THIS FILE AS
//      CHANGES WILL BE OVERWRITTEN.
//
//      *************************** WARNING ***************************
//

using System;

namespace Meadow.Hardware.Coprocessor.MessagePayloads
{
    public static class Encoders
    {
        /// <summary>
        ///     Take two bytes from the buffer and encode them as a 16-bit integer.
        ///     Note that the data should be encoded as LSB first.
        /// </summary>
        /// <param name="buffer">Buffer holding the value.</param>
        /// <param name="offset">Offset into the buffer for the LSB.</param>
        public static UInt16 ExtractUInt16(byte[] buffer, int offset = 0)
        {
            UInt16 result;

            result = buffer[offset];
            result |= (UInt16) (buffer[offset + 1] << 8);
            return (result);
        }

        /// <summary>
        ///     Encode a 16-bit integer as two bytes in the buffer.  The data is
        ///     encoded LSB first.
        /// </summary>
        /// <param name="value">Value to encode.</param>
        /// <param name="buffer">Buffer to store the value.</param>
        /// <param name="offset">Offset into the buffer for the first byte to store.</param>
        public static void EncodeUInt16(UInt16 value, byte[] buffer, int offset = 0)
        {
            buffer[offset] = (byte) (value & 0xff);
            buffer[offset + 1] = (byte) ((value >> 8) & 0xff);
        }

        /// <summary>
        ///     Take four bytes from the buffer and encode them as a 32-bit unsiged integer.
        ///     Note that the data should be encoded as LSB first.
        /// </summary>
        /// <param name="buffer">Buffer holding the 32-bit value to decode.</param>
        /// <param name="offset">Offset of the 32-bit in the buffer.</param>
        public static UInt32 ExtractUInt32(byte[] buffer, int offset = 0)
        {
            UInt32 result;

            result = buffer[offset];
            result |= (UInt32) (buffer[offset + 1] << 8);
            result |= (UInt32) (buffer[offset + 2] << 16);
            result |= (UInt32) (buffer[offset + 3] << 24);
            return (result);
        }

        /// <summary>
        ///     Encode a 32-bit unsigned integer as four bytes in the buffer.  The data is
        ///     encoded LSB first.
        /// </summary>
        /// <param name="value">Value to encode.</param>
        /// <param name="buffer">Buffer to store the value.</param>
        /// <param name="offset">Offset into the buffer for the first byte to store.</param>
        public static void EncodeUInt32(UInt32 value, byte[] buffer, int offset = 0)
        {
            buffer[offset] = (byte) (value & 0xff);
            buffer[offset + 1] = (byte) ((value >> 8) & 0xff);
            buffer[offset + 2] = (byte) ((value >> 16) & 0xff);
            buffer[offset + 3] = (byte) ((value >> 24) & 0xff);
        }

        /// <summary>
        ///     Take four bytes from the buffer and encode them as a 32-bit integer.
        ///     Note that the data should be encoded as LSB first.
        /// </summary>
        /// <param name="buffer">Buffer holding the 32-bit value to decode.</param>
        /// <param name="offset">Offset of the 32-bit in the buffer.</param>
        public static Int32 ExtractInt32(byte[] buffer, int offset = 0)
        {
            Int32 result;

            result = buffer[offset];
            result |= (Int32) (buffer[offset + 1] << 8);
            result |= (Int32) (buffer[offset + 2] << 16);
            result |= (Int32) (buffer[offset + 3] << 24);
            return (result);
        }

        /// <summary>
        ///     Encode a 32-bit integer as four bytes in the buffer.  The data is
        ///     encoded LSB first.
        /// </summary>
        /// <param name="value">Value to encode.</param>
        /// <param name="buffer">Buffer to store the value.</param>
        /// <param name="offset">Offset into the buffer for the first byte to store.</param>
        public static void EncodeInt32(Int32 value, byte[] buffer, int offset = 0)
        {
            buffer[offset] = (byte) (value & 0xff);
            buffer[offset + 1] = (byte) ((value >> 8) & 0xff);
            buffer[offset + 2] = (byte) ((value >> 16) & 0xff);
            buffer[offset + 3] = (byte) ((value >> 24) & 0xff);
        }

        /// <summary>
        ///     Encode a string into the buffer as a stream of bytes.
        /// </summary>
        /// <remarks>
        ///     An additional null terminating byte is added to the end of the string.
        /// </remarks>
        /// <param name="str">String to encode.</param>
        /// <param name="buffer">Buffer to hold the characters.</param>
        /// <param name="offset">Offset into the buffer for the first character.</param>
        public static void EncodeString(string str, byte[] buffer, int offset = 0)
        {
            char[] data = str.ToCharArray();
            foreach (char c in data)
            {
                buffer[offset] = (byte) c;
                offset++;
            }
            buffer[offset] = 0;
        }

        /// <summary>
        ///     Extract a string from the buffer.
        /// </summary>
        /// <remarks>
        ///     Extraction will start offset bytes into the buffer and will
        ///     stop when a 0 (C string terminator) byte in encountered.
        /// </remarks>
        /// <returns>The string.</returns>
        /// <param name="buffer">Buffer holding the data to be decoded.</param>
        /// <param name="offset">Offset into the buffer of the string.</param>
        public static string ExtractString(byte[] buffer, int offset = 0)
        {
            string result = "";

            while (buffer[offset] != 0)
            {
                result += (char) buffer[offset];
                offset++;
            }
            return (result);
        }

        public static byte[] EncodeSystemConfiguration(SystemConfiguration systemConfiguration)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 4;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeUInt32(systemConfiguration.MessageSize, buffer, offset);
            return(buffer);
        }

        public static SystemConfiguration ExtractSystemConfiguration(byte[] buffer, int offset)
        {
            SystemConfiguration systemConfiguration = new MessagePayloads.SystemConfiguration();

            systemConfiguration.MessageSize = ExtractUInt32(buffer, offset);
            return(systemConfiguration);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the SystemConfiguration object.
        /// </summary>
        /// <param name="systemConfiguration">SystemConfiguration object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded SystemConfiguration object.</returns>
        public static int EncodedSystemConfigurationBufferSize(MessagePayloads.SystemConfiguration systemConfiguration)
        {
            return(4);
        }

        public static byte[] EncodeWiFiConfiguration(WiFiConfiguration wiFiConfiguration)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 7;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            buffer[offset] = wiFiConfiguration.AutomaticReconnect;
            offset += 1;
            EncodeUInt32(wiFiConfiguration.MaximumRetryCount, buffer, offset);
            offset += 4;
            buffer[offset] = wiFiConfiguration.Antenna;
            offset += 1;
            buffer[offset] = wiFiConfiguration.MaximumMessageQueueLength;
            return(buffer);
        }

        public static WiFiConfiguration ExtractWiFiConfiguration(byte[] buffer, int offset)
        {
            WiFiConfiguration wiFiConfiguration = new MessagePayloads.WiFiConfiguration();

            wiFiConfiguration.AutomaticReconnect = buffer[offset];
            offset += 1;
            wiFiConfiguration.MaximumRetryCount = ExtractUInt32(buffer, offset);
            offset += 4;
            wiFiConfiguration.Antenna = buffer[offset];
            offset += 1;
            wiFiConfiguration.MaximumMessageQueueLength = buffer[offset];
            return(wiFiConfiguration);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the WiFiConfiguration object.
        /// </summary>
        /// <param name="wiFiConfiguration">WiFiConfiguration object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded WiFiConfiguration object.</returns>
        public static int EncodedWiFiConfigurationBufferSize(MessagePayloads.WiFiConfiguration wiFiConfiguration)
        {
            return(7);
        }

        public static byte[] EncodeWiFiCredentials(WiFiCredentials wiFiCredentials)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (wiFiCredentials.NetworkName.Length + 1);
            length += (int) (wiFiCredentials.Password.Length + 1);

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeString(wiFiCredentials.NetworkName, buffer, offset);
            offset += wiFiCredentials.NetworkName.Length + 1;
            EncodeString(wiFiCredentials.Password, buffer, offset);
            return(buffer);
        }

        public static WiFiCredentials ExtractWiFiCredentials(byte[] buffer, int offset)
        {
            WiFiCredentials wiFiCredentials = new MessagePayloads.WiFiCredentials();

            wiFiCredentials.NetworkName = ExtractString(buffer, offset);
            offset += (int) (wiFiCredentials.NetworkName.Length + 1);
            wiFiCredentials.Password = ExtractString(buffer, offset);
            return(wiFiCredentials);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the WiFiCredentials object.
        /// </summary>
        /// <param name="wiFiCredentials">WiFiCredentials object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded WiFiCredentials object.</returns>
        public static int EncodedWiFiCredentialsBufferSize(MessagePayloads.WiFiCredentials wiFiCredentials)
        {
            int result = 0;
            result += (int) wiFiCredentials.NetworkName.Length;
            result += (int) wiFiCredentials.Password.Length;
            return(result + 2);
        }

        public static byte[] EncodeAntennaInfo(AntennaInfo antennaInfo)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 1;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            buffer[offset] = antennaInfo.Antenna;
            return(buffer);
        }

        public static AntennaInfo ExtractAntennaInfo(byte[] buffer, int offset)
        {
            AntennaInfo antennaInfo = new MessagePayloads.AntennaInfo();

            antennaInfo.Antenna = buffer[offset];
            return(antennaInfo);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the AntennaInfo object.
        /// </summary>
        /// <param name="antennaInfo">AntennaInfo object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded AntennaInfo object.</returns>
        public static int EncodedAntennaInfoBufferSize(MessagePayloads.AntennaInfo antennaInfo)
        {
            return(1);
        }

        public static byte[] EncodeAccessPoint(AccessPoint accessPoint)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) 33;
            length += (int) 6;
            length += 8;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            int amount = accessPoint.Ssid.Length >= 33 ? 33 - 1 : accessPoint.Ssid.Length;
            for (int index = 0; index < amount; index++)
            {
                buffer[index] = (byte) accessPoint.Ssid[index];
            }
            buffer[amount] = 0;
            offset += (int) 33;
            Array.Copy(accessPoint.Bssid, 0, buffer, offset, 6);
            offset += (int) 6;
            buffer[offset] = accessPoint.PrimaryChannel;
            offset += 1;
            buffer[offset] = accessPoint.SecondaryChannel;
            offset += 1;
            buffer[offset] = (byte) accessPoint.Rssi;
            offset += 1;
            buffer[offset] = accessPoint.AuthenticationMode;
            offset += 1;
            EncodeUInt32(accessPoint.Protocols, buffer, offset);
            return(buffer);
        }

        public static AccessPoint ExtractAccessPoint(byte[] buffer, int offset)
        {
            AccessPoint accessPoint = new MessagePayloads.AccessPoint();

            for (int index = 0; (buffer[index + offset] != 0) && (index < (33 - 1)); index++)
            {
                accessPoint.Ssid += Convert.ToChar(buffer[index + offset]);
            }
            offset += (int) 33;
            accessPoint.Bssid = new byte[6];
            Array.Copy(buffer, offset, accessPoint.Bssid, 0, 6);
            offset += (int) 6;
            accessPoint.PrimaryChannel = buffer[offset];
            offset += 1;
            accessPoint.SecondaryChannel = buffer[offset];
            offset += 1;
            accessPoint.Rssi = (sbyte) buffer[offset];
            offset += 1;
            accessPoint.AuthenticationMode = buffer[offset];
            offset += 1;
            accessPoint.Protocols = ExtractUInt32(buffer, offset);
            return(accessPoint);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the AccessPoint object.
        /// </summary>
        /// <param name="accessPoint">AccessPoint object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded AccessPoint object.</returns>
        public static int EncodedAccessPointBufferSize(MessagePayloads.AccessPoint accessPoint)
        {
            return(47);
        }

        public static byte[] EncodeAccessPointList(AccessPointList accessPointList)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (accessPointList.AccessPointsLength + 4);
            length += 4;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeUInt32(accessPointList.NumberOfAccessPoints, buffer, offset);
            offset += 4;
            EncodeUInt32(accessPointList.AccessPointsLength, buffer, offset);
            offset += 4;
            if (accessPointList.AccessPointsLength > 0)
            {
                Array.Copy(accessPointList.AccessPoints, 0, buffer, offset, accessPointList.AccessPointsLength);
            }
            return(buffer);
        }

        public static AccessPointList ExtractAccessPointList(byte[] buffer, int offset)
        {
            AccessPointList accessPointList = new MessagePayloads.AccessPointList();

            accessPointList.NumberOfAccessPoints = ExtractUInt32(buffer, offset);
            offset += 4;
            accessPointList.AccessPointsLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (accessPointList.AccessPointsLength > 0)
            {
                accessPointList.AccessPoints = new byte[accessPointList.AccessPointsLength];
                Array.Copy(buffer, offset, accessPointList.AccessPoints, 0, accessPointList.AccessPointsLength);
            }
            return(accessPointList);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the AccessPointList object.
        /// </summary>
        /// <param name="accessPointList">AccessPointList object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded AccessPointList object.</returns>
        public static int EncodedAccessPointListBufferSize(MessagePayloads.AccessPointList accessPointList)
        {
            int result = 0;
            result += (int) accessPointList.AccessPointsLength;
            return(result + 8);
        }

        public static byte[] EncodeSockAddr(SockAddr sockAddr)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) 14;
            length += 2;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            buffer[offset] = sockAddr.Length;
            offset += 1;
            buffer[offset] = sockAddr.Family;
            offset += 1;
            Array.Copy(sockAddr.Data, 0, buffer, offset, 14);
            return(buffer);
        }

        public static SockAddr ExtractSockAddr(byte[] buffer, int offset)
        {
            SockAddr sockAddr = new MessagePayloads.SockAddr();

            sockAddr.Length = buffer[offset];
            offset += 1;
            sockAddr.Family = buffer[offset];
            offset += 1;
            sockAddr.Data = new byte[14];
            Array.Copy(buffer, offset, sockAddr.Data, 0, 14);
            return(sockAddr);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the SockAddr object.
        /// </summary>
        /// <param name="sockAddr">SockAddr object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded SockAddr object.</returns>
        public static int EncodedSockAddrBufferSize(MessagePayloads.SockAddr sockAddr)
        {
            return(16);
        }

        public static byte[] EncodeAddrInfo(AddrInfo addrInfo)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (addrInfo.AddrLength + 4);
            length += (int) (addrInfo.CanonName.Length + 1);
            length += 28;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeUInt32(addrInfo.MyHeapAddress, buffer, offset);
            offset += 4;
            EncodeInt32(addrInfo.Flags, buffer, offset);
            offset += 4;
            EncodeInt32(addrInfo.Family, buffer, offset);
            offset += 4;
            EncodeInt32(addrInfo.SocketType, buffer, offset);
            offset += 4;
            EncodeInt32(addrInfo.Protocol, buffer, offset);
            offset += 4;
            EncodeUInt32(addrInfo.AddrLen, buffer, offset);
            offset += 4;
            EncodeUInt32(addrInfo.AddrLength, buffer, offset);
            offset += 4;
            if (addrInfo.AddrLength > 0)
            {
                Array.Copy(addrInfo.Addr, 0, buffer, offset, addrInfo.AddrLength);
                offset += (int) (addrInfo.AddrLength);
            }
            EncodeString(addrInfo.CanonName, buffer, offset);
            offset += addrInfo.CanonName.Length + 1;
            EncodeUInt32(addrInfo.Next, buffer, offset);
            return(buffer);
        }

        public static AddrInfo ExtractAddrInfo(byte[] buffer, int offset)
        {
            AddrInfo addrInfo = new MessagePayloads.AddrInfo();

            addrInfo.MyHeapAddress = ExtractUInt32(buffer, offset);
            offset += 4;
            addrInfo.Flags = ExtractInt32(buffer, offset);
            offset += 4;
            addrInfo.Family = ExtractInt32(buffer, offset);
            offset += 4;
            addrInfo.SocketType = ExtractInt32(buffer, offset);
            offset += 4;
            addrInfo.Protocol = ExtractInt32(buffer, offset);
            offset += 4;
            addrInfo.AddrLen = ExtractUInt32(buffer, offset);
            offset += 4;
            addrInfo.AddrLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (addrInfo.AddrLength > 0)
            {
                addrInfo.Addr = new byte[addrInfo.AddrLength];
                Array.Copy(buffer, offset, addrInfo.Addr, 0, addrInfo.AddrLength);
                offset += (int) addrInfo.AddrLength;
            }
            addrInfo.CanonName = ExtractString(buffer, offset);
            offset += (int) (addrInfo.CanonName.Length + 1);
            addrInfo.Next = ExtractUInt32(buffer, offset);
            return(addrInfo);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the AddrInfo object.
        /// </summary>
        /// <param name="addrInfo">AddrInfo object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded AddrInfo object.</returns>
        public static int EncodedAddrInfoBufferSize(MessagePayloads.AddrInfo addrInfo)
        {
            int result = 0;
            result += (int) addrInfo.AddrLength;
            result += (int) addrInfo.CanonName.Length;
            return(result + 33);
        }

        public static byte[] EncodeGetAddrInfoRequest(GetAddrInfoRequest getAddrInfoRequest)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (getAddrInfoRequest.NodeName.Length + 1);
            length += (int) (getAddrInfoRequest.ServName.Length + 1);
            length += (int) (getAddrInfoRequest.HintsLength + 4);
            length += (int) (getAddrInfoRequest.ResultLength + 4);

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeString(getAddrInfoRequest.NodeName, buffer, offset);
            offset += getAddrInfoRequest.NodeName.Length + 1;
            EncodeString(getAddrInfoRequest.ServName, buffer, offset);
            offset += getAddrInfoRequest.ServName.Length + 1;
            EncodeUInt32(getAddrInfoRequest.HintsLength, buffer, offset);
            offset += 4;
            if (getAddrInfoRequest.HintsLength > 0)
            {
                Array.Copy(getAddrInfoRequest.Hints, 0, buffer, offset, getAddrInfoRequest.HintsLength);
                offset += (int) (getAddrInfoRequest.HintsLength);
            }
            EncodeUInt32(getAddrInfoRequest.ResultLength, buffer, offset);
            offset += 4;
            if (getAddrInfoRequest.ResultLength > 0)
            {
                Array.Copy(getAddrInfoRequest.Result, 0, buffer, offset, getAddrInfoRequest.ResultLength);
            }
            return(buffer);
        }

        public static GetAddrInfoRequest ExtractGetAddrInfoRequest(byte[] buffer, int offset)
        {
            GetAddrInfoRequest getAddrInfoRequest = new MessagePayloads.GetAddrInfoRequest();

            getAddrInfoRequest.NodeName = ExtractString(buffer, offset);
            offset += (int) (getAddrInfoRequest.NodeName.Length + 1);
            getAddrInfoRequest.ServName = ExtractString(buffer, offset);
            offset += (int) (getAddrInfoRequest.ServName.Length + 1);
            getAddrInfoRequest.HintsLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (getAddrInfoRequest.HintsLength > 0)
            {
                getAddrInfoRequest.Hints = new byte[getAddrInfoRequest.HintsLength];
                Array.Copy(buffer, offset, getAddrInfoRequest.Hints, 0, getAddrInfoRequest.HintsLength);
                offset += (int) getAddrInfoRequest.HintsLength;
            }
            getAddrInfoRequest.ResultLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (getAddrInfoRequest.ResultLength > 0)
            {
                getAddrInfoRequest.Result = new byte[getAddrInfoRequest.ResultLength];
                Array.Copy(buffer, offset, getAddrInfoRequest.Result, 0, getAddrInfoRequest.ResultLength);
            }
            return(getAddrInfoRequest);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the GetAddrInfoRequest object.
        /// </summary>
        /// <param name="getAddrInfoRequest">GetAddrInfoRequest object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded GetAddrInfoRequest object.</returns>
        public static int EncodedGetAddrInfoRequestBufferSize(MessagePayloads.GetAddrInfoRequest getAddrInfoRequest)
        {
            int result = 0;
            result += (int) getAddrInfoRequest.NodeName.Length;
            result += (int) getAddrInfoRequest.ServName.Length;
            result += (int) getAddrInfoRequest.HintsLength;
            result += (int) getAddrInfoRequest.ResultLength;
            return(result + 10);
        }

        public static byte[] EncodeGetAddrInfoResponse(GetAddrInfoResponse getAddrInfoResponse)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (getAddrInfoResponse.ResLength + 4);
            length += 4;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(getAddrInfoResponse.AddrInfoResponseErrno, buffer, offset);
            offset += 4;
            EncodeUInt32(getAddrInfoResponse.ResLength, buffer, offset);
            offset += 4;
            if (getAddrInfoResponse.ResLength > 0)
            {
                Array.Copy(getAddrInfoResponse.Res, 0, buffer, offset, getAddrInfoResponse.ResLength);
            }
            return(buffer);
        }

        public static GetAddrInfoResponse ExtractGetAddrInfoResponse(byte[] buffer, int offset)
        {
            GetAddrInfoResponse getAddrInfoResponse = new MessagePayloads.GetAddrInfoResponse();

            getAddrInfoResponse.AddrInfoResponseErrno = ExtractInt32(buffer, offset);
            offset += 4;
            getAddrInfoResponse.ResLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (getAddrInfoResponse.ResLength > 0)
            {
                getAddrInfoResponse.Res = new byte[getAddrInfoResponse.ResLength];
                Array.Copy(buffer, offset, getAddrInfoResponse.Res, 0, getAddrInfoResponse.ResLength);
            }
            return(getAddrInfoResponse);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the GetAddrInfoResponse object.
        /// </summary>
        /// <param name="getAddrInfoResponse">GetAddrInfoResponse object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded GetAddrInfoResponse object.</returns>
        public static int EncodedGetAddrInfoResponseBufferSize(MessagePayloads.GetAddrInfoResponse getAddrInfoResponse)
        {
            int result = 0;
            result += (int) getAddrInfoResponse.ResLength;
            return(result + 8);
        }

        public static byte[] EncodeSocketRequest(SocketRequest socketRequest)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 16;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeUInt32(socketRequest.AddressInformation, buffer, offset);
            offset += 4;
            EncodeInt32(socketRequest.Domain, buffer, offset);
            offset += 4;
            EncodeInt32(socketRequest.Type, buffer, offset);
            offset += 4;
            EncodeInt32(socketRequest.Protocol, buffer, offset);
            return(buffer);
        }

        public static SocketRequest ExtractSocketRequest(byte[] buffer, int offset)
        {
            SocketRequest socketRequest = new MessagePayloads.SocketRequest();

            socketRequest.AddressInformation = ExtractUInt32(buffer, offset);
            offset += 4;
            socketRequest.Domain = ExtractInt32(buffer, offset);
            offset += 4;
            socketRequest.Type = ExtractInt32(buffer, offset);
            offset += 4;
            socketRequest.Protocol = ExtractInt32(buffer, offset);
            return(socketRequest);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the SocketRequest object.
        /// </summary>
        /// <param name="socketRequest">SocketRequest object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded SocketRequest object.</returns>
        public static int EncodedSocketRequestBufferSize(MessagePayloads.SocketRequest socketRequest)
        {
            return(16);
        }

        public static byte[] EncodeIntegerResponse(IntegerResponse integerResponse)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 4;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(integerResponse.Result, buffer, offset);
            return(buffer);
        }

        public static IntegerResponse ExtractIntegerResponse(byte[] buffer, int offset)
        {
            IntegerResponse integerResponse = new MessagePayloads.IntegerResponse();

            integerResponse.Result = ExtractInt32(buffer, offset);
            return(integerResponse);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the IntegerResponse object.
        /// </summary>
        /// <param name="integerResponse">IntegerResponse object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded IntegerResponse object.</returns>
        public static int EncodedIntegerResponseBufferSize(MessagePayloads.IntegerResponse integerResponse)
        {
            return(4);
        }

        public static byte[] EncodeIntegerAndErrnoResponse(IntegerAndErrnoResponse integerAndErrnoResponse)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 8;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(integerAndErrnoResponse.Result, buffer, offset);
            offset += 4;
            EncodeInt32(integerAndErrnoResponse.ResponseErrno, buffer, offset);
            return(buffer);
        }

        public static IntegerAndErrnoResponse ExtractIntegerAndErrnoResponse(byte[] buffer, int offset)
        {
            IntegerAndErrnoResponse integerAndErrnoResponse = new MessagePayloads.IntegerAndErrnoResponse();

            integerAndErrnoResponse.Result = ExtractInt32(buffer, offset);
            offset += 4;
            integerAndErrnoResponse.ResponseErrno = ExtractInt32(buffer, offset);
            return(integerAndErrnoResponse);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the IntegerAndErrnoResponse object.
        /// </summary>
        /// <param name="integerAndErrnoResponse">IntegerAndErrnoResponse object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded IntegerAndErrnoResponse object.</returns>
        public static int EncodedIntegerAndErrnoResponseBufferSize(MessagePayloads.IntegerAndErrnoResponse integerAndErrnoResponse)
        {
            return(8);
        }

        public static byte[] EncodeConnectRequest(ConnectRequest connectRequest)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (connectRequest.AddrLength + 4);
            length += 8;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(connectRequest.SocketHandle, buffer, offset);
            offset += 4;
            EncodeUInt32(connectRequest.AddrLength, buffer, offset);
            offset += 4;
            if (connectRequest.AddrLength > 0)
            {
                Array.Copy(connectRequest.Addr, 0, buffer, offset, connectRequest.AddrLength);
                offset += (int) (connectRequest.AddrLength);
            }
            EncodeInt32(connectRequest.AddrLen, buffer, offset);
            return(buffer);
        }

        public static ConnectRequest ExtractConnectRequest(byte[] buffer, int offset)
        {
            ConnectRequest connectRequest = new MessagePayloads.ConnectRequest();

            connectRequest.SocketHandle = ExtractInt32(buffer, offset);
            offset += 4;
            connectRequest.AddrLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (connectRequest.AddrLength > 0)
            {
                connectRequest.Addr = new byte[connectRequest.AddrLength];
                Array.Copy(buffer, offset, connectRequest.Addr, 0, connectRequest.AddrLength);
                offset += (int) connectRequest.AddrLength;
            }
            connectRequest.AddrLen = ExtractInt32(buffer, offset);
            return(connectRequest);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the ConnectRequest object.
        /// </summary>
        /// <param name="connectRequest">ConnectRequest object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded ConnectRequest object.</returns>
        public static int EncodedConnectRequestBufferSize(MessagePayloads.ConnectRequest connectRequest)
        {
            int result = 0;
            result += (int) connectRequest.AddrLength;
            return(result + 12);
        }

        public static byte[] EncodeFreeAddrInfoRequest(FreeAddrInfoRequest freeAddrInfoRequest)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 4;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeUInt32(freeAddrInfoRequest.AddrInfoAddress, buffer, offset);
            return(buffer);
        }

        public static FreeAddrInfoRequest ExtractFreeAddrInfoRequest(byte[] buffer, int offset)
        {
            FreeAddrInfoRequest freeAddrInfoRequest = new MessagePayloads.FreeAddrInfoRequest();

            freeAddrInfoRequest.AddrInfoAddress = ExtractUInt32(buffer, offset);
            return(freeAddrInfoRequest);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the FreeAddrInfoRequest object.
        /// </summary>
        /// <param name="freeAddrInfoRequest">FreeAddrInfoRequest object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded FreeAddrInfoRequest object.</returns>
        public static int EncodedFreeAddrInfoRequestBufferSize(MessagePayloads.FreeAddrInfoRequest freeAddrInfoRequest)
        {
            return(4);
        }

        public static byte[] EncodeTimeVal(TimeVal timeVal)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 8;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeUInt32(timeVal.TvSec, buffer, offset);
            offset += 4;
            EncodeUInt32(timeVal.TvUsec, buffer, offset);
            return(buffer);
        }

        public static TimeVal ExtractTimeVal(byte[] buffer, int offset)
        {
            TimeVal timeVal = new MessagePayloads.TimeVal();

            timeVal.TvSec = ExtractUInt32(buffer, offset);
            offset += 4;
            timeVal.TvUsec = ExtractUInt32(buffer, offset);
            return(timeVal);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the TimeVal object.
        /// </summary>
        /// <param name="timeVal">TimeVal object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded TimeVal object.</returns>
        public static int EncodedTimeValBufferSize(MessagePayloads.TimeVal timeVal)
        {
            return(8);
        }

        public static byte[] EncodeSetSockOptRequest(SetSockOptRequest setSockOptRequest)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (setSockOptRequest.OptionValueLength + 4);
            length += 16;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(setSockOptRequest.SocketNumber, buffer, offset);
            offset += 4;
            EncodeInt32(setSockOptRequest.Level, buffer, offset);
            offset += 4;
            EncodeInt32(setSockOptRequest.OptionName, buffer, offset);
            offset += 4;
            EncodeUInt32(setSockOptRequest.OptionValueLength, buffer, offset);
            offset += 4;
            if (setSockOptRequest.OptionValueLength > 0)
            {
                Array.Copy(setSockOptRequest.OptionValue, 0, buffer, offset, setSockOptRequest.OptionValueLength);
                offset += (int) (setSockOptRequest.OptionValueLength);
            }
            EncodeInt32(setSockOptRequest.OptionLen, buffer, offset);
            return(buffer);
        }

        public static SetSockOptRequest ExtractSetSockOptRequest(byte[] buffer, int offset)
        {
            SetSockOptRequest setSockOptRequest = new MessagePayloads.SetSockOptRequest();

            setSockOptRequest.SocketNumber = ExtractInt32(buffer, offset);
            offset += 4;
            setSockOptRequest.Level = ExtractInt32(buffer, offset);
            offset += 4;
            setSockOptRequest.OptionName = ExtractInt32(buffer, offset);
            offset += 4;
            setSockOptRequest.OptionValueLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (setSockOptRequest.OptionValueLength > 0)
            {
                setSockOptRequest.OptionValue = new byte[setSockOptRequest.OptionValueLength];
                Array.Copy(buffer, offset, setSockOptRequest.OptionValue, 0, setSockOptRequest.OptionValueLength);
                offset += (int) setSockOptRequest.OptionValueLength;
            }
            setSockOptRequest.OptionLen = ExtractInt32(buffer, offset);
            return(setSockOptRequest);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the SetSockOptRequest object.
        /// </summary>
        /// <param name="setSockOptRequest">SetSockOptRequest object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded SetSockOptRequest object.</returns>
        public static int EncodedSetSockOptRequestBufferSize(MessagePayloads.SetSockOptRequest setSockOptRequest)
        {
            int result = 0;
            result += (int) setSockOptRequest.OptionValueLength;
            return(result + 20);
        }

        public static byte[] EncodeLinger(Linger linger)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 8;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(linger.LOnOff, buffer, offset);
            offset += 4;
            EncodeInt32(linger.LLinger, buffer, offset);
            return(buffer);
        }

        public static Linger ExtractLinger(byte[] buffer, int offset)
        {
            Linger linger = new MessagePayloads.Linger();

            linger.LOnOff = ExtractInt32(buffer, offset);
            offset += 4;
            linger.LLinger = ExtractInt32(buffer, offset);
            return(linger);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the Linger object.
        /// </summary>
        /// <param name="linger">Linger object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded Linger object.</returns>
        public static int EncodedLingerBufferSize(MessagePayloads.Linger linger)
        {
            return(8);
        }

        public static byte[] EncodeWriteRequest(WriteRequest writeRequest)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (writeRequest.BufferLength + 4);
            length += 8;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(writeRequest.SocketHandle, buffer, offset);
            offset += 4;
            EncodeUInt32(writeRequest.BufferLength, buffer, offset);
            offset += 4;
            if (writeRequest.BufferLength > 0)
            {
                Array.Copy(writeRequest.Buffer, 0, buffer, offset, writeRequest.BufferLength);
                offset += (int) (writeRequest.BufferLength);
            }
            EncodeInt32(writeRequest.Count, buffer, offset);
            return(buffer);
        }

        public static WriteRequest ExtractWriteRequest(byte[] buffer, int offset)
        {
            WriteRequest writeRequest = new MessagePayloads.WriteRequest();

            writeRequest.SocketHandle = ExtractInt32(buffer, offset);
            offset += 4;
            writeRequest.BufferLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (writeRequest.BufferLength > 0)
            {
                writeRequest.Buffer = new byte[writeRequest.BufferLength];
                Array.Copy(buffer, offset, writeRequest.Buffer, 0, writeRequest.BufferLength);
                offset += (int) writeRequest.BufferLength;
            }
            writeRequest.Count = ExtractInt32(buffer, offset);
            return(writeRequest);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the WriteRequest object.
        /// </summary>
        /// <param name="writeRequest">WriteRequest object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded WriteRequest object.</returns>
        public static int EncodedWriteRequestBufferSize(MessagePayloads.WriteRequest writeRequest)
        {
            int result = 0;
            result += (int) writeRequest.BufferLength;
            return(result + 12);
        }

        public static byte[] EncodeReadRequest(ReadRequest readRequest)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 8;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(readRequest.SocketHandle, buffer, offset);
            offset += 4;
            EncodeInt32(readRequest.Count, buffer, offset);
            return(buffer);
        }

        public static ReadRequest ExtractReadRequest(byte[] buffer, int offset)
        {
            ReadRequest readRequest = new MessagePayloads.ReadRequest();

            readRequest.SocketHandle = ExtractInt32(buffer, offset);
            offset += 4;
            readRequest.Count = ExtractInt32(buffer, offset);
            return(readRequest);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the ReadRequest object.
        /// </summary>
        /// <param name="readRequest">ReadRequest object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded ReadRequest object.</returns>
        public static int EncodedReadRequestBufferSize(MessagePayloads.ReadRequest readRequest)
        {
            return(8);
        }

        public static byte[] EncodeReadResponse(ReadResponse readResponse)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += (int) (readResponse.BufferLength + 4);
            length += 8;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeUInt32(readResponse.BufferLength, buffer, offset);
            offset += 4;
            if (readResponse.BufferLength > 0)
            {
                Array.Copy(readResponse.Buffer, 0, buffer, offset, readResponse.BufferLength);
                offset += (int) (readResponse.BufferLength);
            }
            EncodeInt32(readResponse.ReadResponseResult, buffer, offset);
            offset += 4;
            EncodeInt32(readResponse.ReadResponseErrno, buffer, offset);
            return(buffer);
        }

        public static ReadResponse ExtractReadResponse(byte[] buffer, int offset)
        {
            ReadResponse readResponse = new MessagePayloads.ReadResponse();

            readResponse.BufferLength = ExtractUInt32(buffer, offset);
            offset += 4;
            if (readResponse.BufferLength > 0)
            {
                readResponse.Buffer = new byte[readResponse.BufferLength];
                Array.Copy(buffer, offset, readResponse.Buffer, 0, readResponse.BufferLength);
                offset += (int) readResponse.BufferLength;
            }
            readResponse.ReadResponseResult = ExtractInt32(buffer, offset);
            offset += 4;
            readResponse.ReadResponseErrno = ExtractInt32(buffer, offset);
            return(readResponse);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the ReadResponse object.
        /// </summary>
        /// <param name="readResponse">ReadResponse object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded ReadResponse object.</returns>
        public static int EncodedReadResponseBufferSize(MessagePayloads.ReadResponse readResponse)
        {
            int result = 0;
            result += (int) readResponse.BufferLength;
            return(result + 12);
        }

        public static byte[] EncodeCloseRequest(CloseRequest closeRequest)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 4;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeInt32(closeRequest.SocketHandle, buffer, offset);
            return(buffer);
        }

        public static CloseRequest ExtractCloseRequest(byte[] buffer, int offset)
        {
            CloseRequest closeRequest = new MessagePayloads.CloseRequest();

            closeRequest.SocketHandle = ExtractInt32(buffer, offset);
            return(closeRequest);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the CloseRequest object.
        /// </summary>
        /// <param name="closeRequest">CloseRequest object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded CloseRequest object.</returns>
        public static int EncodedCloseRequestBufferSize(MessagePayloads.CloseRequest closeRequest)
        {
            return(4);
        }

        public static byte[] EncodeGetBatteryChargeLevelResponse(GetBatteryChargeLevelResponse getBatteryChargeLevelResponse)
        {
            int offset = 0;
            int length = 0;

            //
            //  Calculate the amount of memory needed.
            //
            length += 4;

            //
            //  Now allocate a new buffer and copy the data in to the buffer.
            //
            byte[] buffer = new byte[length];
            Array.Clear(buffer, 0, buffer.Length);
            EncodeUInt32(getBatteryChargeLevelResponse.Level, buffer, offset);
            return(buffer);
        }

        public static GetBatteryChargeLevelResponse ExtractGetBatteryChargeLevelResponse(byte[] buffer, int offset)
        {
            GetBatteryChargeLevelResponse getBatteryChargeLevelResponse = new MessagePayloads.GetBatteryChargeLevelResponse();

            getBatteryChargeLevelResponse.Level = ExtractUInt32(buffer, offset);
            return(getBatteryChargeLevelResponse);
        }

        /// <summary>
        /// Calculate the amount of memory required to hold the given instance of the GetBatteryChargeLevelResponse object.
        /// </summary>
        /// <param name="getBatteryChargeLevelResponse">GetBatteryChargeLevelResponse object to be encoded.</param>
        /// <returns>Number of bytes required to hold the encoded GetBatteryChargeLevelResponse object.</returns>
        public static int EncodedGetBatteryChargeLevelResponseBufferSize(MessagePayloads.GetBatteryChargeLevelResponse getBatteryChargeLevelResponse)
        {
            return(4);
        }

    }
}
